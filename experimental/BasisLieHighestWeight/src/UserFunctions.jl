@doc """
basis_lie_highest_weight(
    type::Symbol,
    rank::Int, 
    highest_weight::Vector{Int};
    reduced_expression::Union{String, Vector{Union{Int, Vector{Int}}}} = "regular", 
    monomial_ordering::Union{Symbol, Function} = :degrevlex, 
)

Computes a monomial basis for the highest weight module with highest weight
``highest_weight`` (in terms of the fundamental weights), for a simple Lie algebra of type
``type`` and rank ``rank``.

# Parameters
- `type`: type of liealgebra we want to investigate, one of :A, :B, :C, :D, :E, :F, :G
- `rank`: rank of liealgebra
- `highest_weight`: highest-weight
- `reduced_expression`: list of operators, either "regular" or integer array. The functionality of choosing a random longest word
                is currently not implemented, because we used https://github.com/jmichel7/Gapjm.jl to work with coxeter 
                groups need a method to obtain all non left descending elements to extend a word
- `monomial_ordering`: monomial order in which our basis gets defined with regards to our operators 

# Examples
```jldoctest
julia> base = BasisLieHighestWeight.basis_lie_highest_weight(:A, 2, [1, 1])
Monomial basis of a highest weight module
  of highest weight [1, 1]
  of dimension 8
  with monomial ordering degrevlex
over lie-Algebra of type A and rank 2
  where the birational sequence used consists of operators to the following weights (given as coefficients w.r.t. alpha_i):
    [1, 0]
    [0, 1]
    [1, 1]
  and the basis was generated by Minkowski sums of the bases of the following highest weight modules:
    [1, 0]
    [0, 1]

julia> base = BasisLieHighestWeight.basis_lie_highest_weight(:A, 3, [2, 2, 3]; monomial_ordering = :lex)
Monomial basis of a highest weight module
  of highest weight [2, 2, 3]
  of dimension 1260
  with monomial ordering lex
over lie-Algebra of type A and rank 3
  where the birational sequence used consists of operators to the following weights (given as coefficients w.r.t. alpha_i):
    [1, 0, 0]
    [0, 1, 0]
    [0, 0, 1]
    [1, 1, 0]
    [0, 1, 1]
    [1, 1, 1]
  and the basis was generated by Minkowski sums of the bases of the following highest weight modules:
    [1, 0, 0]
    [0, 1, 0]
    [0, 0, 1]

julia> base = BasisLieHighestWeight.basis_lie_highest_weight(:A, 2, [1, 0]; birational_sequence=[1,2,1])
Monomial basis of a highest weight module
  of highest weight [1, 0]
  of dimension 3
  with monomial ordering degrevlex
over lie-Algebra of type A and rank 2
  where the birational sequence used consists of operators to the following weights (given as coefficients w.r.t. alpha_i):
    [1, 0]
    [0, 1]
    [1, 0]
  and the basis was generated by Minkowski sums of the bases of the following highest weight modules:
    [1, 0]

julia> base = BasisLieHighestWeight.basis_lie_highest_weight(:C, 3, [1, 1, 1]; monomial_ordering = :lex)
Monomial basis of a highest weight module
  of highest weight [1, 1, 1]
  of dimension 512
  with monomial ordering lex
over lie-Algebra of type C and rank 3
  where the birational sequence used consists of operators to the following weights (given as coefficients w.r.t. alpha_i):
    [1, 0, 0]
    [0, 1, 0]
    [0, 0, 1]
    [1, 1, 0]
    [0, 1, 1]
    [1, 1, 1]
    [0, 2, 1]
    [1, 2, 1]
    [2, 2, 1]
  and the basis was generated by Minkowski sums of the bases of the following highest weight modules:
    [1, 0, 0]
    [0, 1, 0]
    [0, 0, 1]
    [0, 1, 1]
    [1, 1, 1]
```
"""
function basis_lie_highest_weight(
  type::Symbol,
  rank::Int,
  highest_weight::Vector{Int};
  birational_sequence::Union{String,Vector{Int},Vector{GAP.GapObj},Any}="regular", # regular = all pos. roots in order of GAP
  monomial_ordering::Union{Symbol,Function}=:degrevlex,
)
  """
  Standard function with all options
  """
  lie_algebra, chevalley_basis = lie_algebra_with_basis(type, rank)
  operators = get_operators_normal(lie_algebra, chevalley_basis, birational_sequence)
  return basis_lie_highest_weight_compute(
    lie_algebra, chevalley_basis, highest_weight, operators, monomial_ordering
  )
end

@doc """
# Examples
```jldoctest
julia> base = BasisLieHighestWeight.basis_lie_highest_weight_lustzig(:D, 4, [1,1,1,1]; reduced_expression=[4,3,2,4,3,2,1,2,4,3,2,1])
ERROR: not working currently
Stacktrace:
 [1] error(s::String)
   @ Base ./error.jl:35
 [2] basis_lie_highest_weight_lustzig(type::Symbol, rank::Int64, highest_weight::Vector{Int64}; reduced_expression::Vector{Int64})
   @ Oscar.BasisLieHighestWeight ~/code/julia/Oscar.jl/experimental/BasisLieHighestWeight/src/UserFunctions.jl:160
 [3] top-level scope
   @ none:1
```
keep track of correct output:

Monomial basis of a highest weight module
  of highest weight [1, 1, 1, 1]
  of dimension 4096
  with monomial ordering oplex
over lie-Algebra of type D and rank 4
  where the birational sequence used consists of operators to the following weights (given as coefficients w.r.t. alpha_i):
    [0, 0, 0, 1]
    [0, 0, 1, 0]
    [0, 1, 1, 1]
    [0, 1, 1, 0]
    [0, 1, 0, 1]
    [0, 1, 0, 0]
    [1, 2, 1, 1]
    [1, 1, 1, 1]
    [1, 1, 0, 1]
    [1, 1, 1, 0]
    [1, 1, 0, 0]
    [1, 0, 0, 0]
  and the basis was generated by Minkowski sums of the bases of the following highest weight modules:
    [1, 0, 0, 0]
    [0, 1, 0, 0]
    [0, 0, 1, 0]
    [0, 0, 0, 1]
    [0, 0, 1, 1]
"""
function basis_lie_highest_weight_lustzig(
  type::Symbol, rank::Int, highest_weight::Vector{Int}; reduced_expression::Vector{Int}
)
  """
  Lustzig polytope
  BasisLieHighestWeight.basis_lie_highest_weight_lustzig(:D, 4, [1,1,1,1], [4,3,2,4,3,2,1,2,4,3,2,1])
  """
  # operators = some sequence of the String / Littelmann-Berenstein-Zelevinsky polytope
  error("not working currently")
  monomial_ordering = :wdegrevlex
  # TODO: weighting = height = -sum_i c_i, where root = sum_i c_i alpha_i
  lie_algebra, chevalley_basis = lie_algebra_with_basis(type, rank)
  operators = get_operators_lustzig(lie_algebra, chevalley_basis, reduced_expression)
  return basis_lie_highest_weight_compute(
    lie_algebra, chevalley_basis, highest_weight, operators, monomial_ordering
  )
end

@doc """
# Examples
```jldoctest
julia> BasisLieHighestWeight.basis_lie_highest_weight_string(:B, 3, [1,1,1]; reduced_expression=[3,2,3,2,1,2,3,2,1])
Monomial basis of a highest weight module
  of highest weight [1, 1, 1]
  of dimension 512
  with monomial ordering neglex
over lie-Algebra of type B and rank 3
  where the birational sequence used consists of operators to the following weights (given as coefficients w.r.t. alpha_i):
    [0, 0, 1]
    [0, 1, 0]
    [0, 0, 1]
    [0, 1, 0]
    [1, 0, 0]
    [0, 1, 0]
    [0, 0, 1]
    [0, 1, 0]
    [1, 0, 0]
  and the basis was generated by Minkowski sums of the bases of the following highest weight modules:
    [1, 0, 0]
    [0, 1, 0]
    [0, 0, 1]
```
"""
function basis_lie_highest_weight_string(
  type::Symbol, rank::Int, highest_weight::Vector{Int}; reduced_expression::Vector{Int}
)
  """
  String / Littelmann-Berenstein-Zelevinsky polytope
  BasisLieHighestWeight.basis_lie_highest_weight_string(:B, 3, [1,1,1], [3,2,3,2,1,2,3,2,1])
  BasisLieHighestWeight.basis_lie_highest_weight_string(:B, 4, [1,1,1,1], [4,3,4,3,2,3,4,3,2,1,2,3,4,3,2,1])
  BasisLieHighestWeight.basis_lie_highest_weight_string(:A, 4, [1,1,1,1], [4,3,2,1,2,3,4,3,2,3])
  """
  # reduced_expression = some sequence of the String / Littelmann-Berenstein-Zelevinsky polytope
  monomial_ordering = :neglex
  lie_algebra, chevalley_basis = lie_algebra_with_basis(type, rank)
  operators = get_operators_normal(lie_algebra, chevalley_basis, reduced_expression)
  return basis_lie_highest_weight_compute(
    lie_algebra, chevalley_basis, highest_weight, operators, monomial_ordering
  )
end

@doc """
# Examples
```jldoctest
julia> BasisLieHighestWeight.basis_lie_highest_weight_pbw(:A, 3, [1,1,1])
Monomial basis of a highest weight module
  of highest weight [1, 1, 1]
  of dimension 64
  with monomial ordering neglex
over lie-Algebra of type A and rank 3
  where the birational sequence used consists of operators to the following weights (given as coefficients w.r.t. alpha_i):
    [1, 1, 1]
    [0, 1, 1]
    [1, 1, 0]
    [0, 0, 1]
    [0, 1, 0]
    [1, 0, 0]
  and the basis was generated by Minkowski sums of the bases of the following highest weight modules:
    [1, 0, 0]
    [0, 1, 0]
    [0, 0, 1]
```
"""
function basis_lie_highest_weight_pbw(type::Symbol, rank::Int, highest_weight::Vector{Int})
  """
  Feigin-Fourier-Littelmann-Vinberg polytope
  BasisLieHighestWeight.basis_lie_highest_weight_pbw(:A, 3, [1,1,1])
  """
  monomial_ordering = :neglex
  lie_algebra, chevalley_basis = lie_algebra_with_basis(type, rank)
  operators = reverse(get_operators_normal(lie_algebra, chevalley_basis, "regular"))
  return basis_lie_highest_weight_compute(
    lie_algebra, chevalley_basis, highest_weight, operators, monomial_ordering
  )
end

@doc """
# Examples
```jldoctest
julia> BasisLieHighestWeight.basis_lie_highest_weight_nz(:C, 3, [1,1,1]; reduced_expression=[3,2,3,2,1,2,3,2,1])
Monomial basis of a highest weight module
  of highest weight [1, 1, 1]
  of dimension 512
  with monomial ordering degrevlex
over lie-Algebra of type C and rank 3
  where the birational sequence used consists of operators to the following weights (given as coefficients w.r.t. alpha_i):
    [0, 0, 1]
    [0, 1, 0]
    [0, 0, 1]
    [0, 1, 0]
    [1, 0, 0]
    [0, 1, 0]
    [0, 0, 1]
    [0, 1, 0]
    [1, 0, 0]
  and the basis was generated by Minkowski sums of the bases of the following highest weight modules:
    [1, 0, 0]
    [0, 1, 0]
    [0, 0, 1]
```
"""
function basis_lie_highest_weight_nz(
  type::Symbol, rank::Int, highest_weight::Vector{Int}; reduced_expression::Vector{Int}
)
  """
  Nakashima-Zelevinsky polytope
  BasisLieHighestWeight.basis_lie_highest_weight_nz(:C, 3, [1,1,1], [3,2,3,2,1,2,3,2,1])
  BasisLieHighestWeight.basis_lie_highest_weight_nz(:A, 4, [1,1,1,1], [4,3,2,1,2,3,4,3,2,3])
  """
  monomial_ordering = :degrevlex
  lie_algebra, chevalley_basis = lie_algebra_with_basis(type, rank)
  operators = get_operators_normal(lie_algebra, chevalley_basis, reduced_expression)
  return basis_lie_highest_weight_compute(
    lie_algebra, chevalley_basis, highest_weight, operators, monomial_ordering
  )
end
